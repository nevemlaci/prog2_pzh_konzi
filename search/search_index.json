{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Gy\u00e9m\u00e1nt \u00f6r\u00f6kl\u00e9s feladat \u00daj neptun rendszer (Neptun) ker\u00fcl fejleszt\u00e9sre, heves vit\u00e1k ut\u00e1n a vezet\u0151s\u00e9g a C++ mellett tette le a voks\u00e1t. Feladatunk most egy demo program k\u00e9sz\u00edt\u00e9se a rendszer modellez\u00e9s\u00e9re, amit k\u00e9s\u0151bb lehet hogy tov\u00e1bb b\u0151v\u00edt\u00fcnk. Szeretn\u00e9nk nyilv\u00e1ntartani minden egyetemi polg\u00e1rt ( Polgar ), minden polg\u00e1rnak van neve \u00e9s \u00e9letkora. Az egyetemen a polg\u00e1rokhoz tartoznak a Hallgat\u00f3 k \u00e9s a Tan\u00e1r ok is. A hallgat\u00f3k sz\u00e1mon tartj\u00e1k az eddig teljes\u00edtett kreditek \u00f6sszeg\u00e9t, m\u00edg a tan\u00e1rok az eddig konzult\u00e1lt hallgat\u00f3k sz\u00e1m\u00e1t. Speci\u00e1lis helyzetben vannak a Doktoranduszok, akik hallgat\u00f3k \u00e9s tan\u00e1rok is egyben. Mindenkinek ki\u00edrhat\u00f3 a neve \u00e9s \u00e9letkora, valamint a hallgat\u00f3kn\u00e1l a teljes\u00edtett kredit, tan\u00e1rokn\u00e1l a konzult\u00e1lt hallgat\u00f3k sz\u00e1ma. Doktorandusz viselkedhet tan\u00e1rk\u00e9nt \u00e9s hallgat\u00f3k\u00e9nt is. Minden egyedn\u00e9l ki\u00edrhat\u00f3k ( kiir() ) ezek az \u00e9rt\u00e9kek a kapott ostream param\u00e9terre. A Neptun rendszerbe \u00faj polg\u00e1rt bevinni a hozzaad() met\u00f3dussal lehet, illetve param\u00e9terben megadott adatfolyamra ki lehet list\u00e1zni az \u00f6sszes egyetemi polg\u00e1r minden adat\u00e1t ( listaz() ). Ha a Neptun rendszer megsemmis\u00fcl, a benne t\u00e1rolt adatok is elvesznek. Gondoljuk v\u00e9gig! Az modell\u00fcnk a k\u00f6vetkez\u0151: Van egy Polgar \u0151soszt\u00e1ly Bel\u0151le sz\u00e1rmazik a Tanar \u00e9s a Hallgato A Doktorandusz egyszerre Tanar \u00e9s Hallgato is Ez gy\u00e9m\u00e1nt \u00f6r\u00f6kl\u00e9s probl\u00e9ma! A Doktorandusz oszt\u00e1lyban a Polgar mem\u00f3riak\u00e9pe k\u00e9tszer, a Tanar \u00e9s Hallgato oszt\u00e1lyon kereszt\u00fcl is megjelenik. A megold\u00e1s: virtu\u00e1lis \u0151s kell a Tanar \u00e9s Hallgato oszt\u00e1lynak! Tan\u00e1r #ifndef TANAR_H_DEFINED #define TANAR_H_DEFINED #include \"polgar.h\" class Tanar : [ /*...*/ ] { int konzultalt ; //eddig konzult\u00e1lt hallgat\u00f3k sz\u00e1ma public : Tanar ( string nev , int kor , int konzultalt ) [ /*...*/ ], konzultalt ( konzultalt ) {} void kiir ( ostream & os ) const { [ /*...*/ ] // ki\u00edrjuk a nev\u00e9t \u00e9s a kor\u00e1t os << \", konzultalt: \" << konzultalt ; } }; #endif Megold\u00e1s #ifndef TANAR_H_DEFINED #define TANAR_H_DEFINED #include \"polgar.h\" class Tanar : [ virtual public Polgar ] { //virtual base, mivel gy\u00e9m\u00e1nt probl\u00e9ma van. int konzultalt ; //eddig konzult\u00e1lt hallgat\u00f3k sz\u00e1ma public : Tanar ( string nev , int kor , int konzultalt ) [ : Polgar ( nev , kor )], konzultalt ( konzultalt ) {} void kiir ( ostream & os ) const { [ Polgar :: kiir ( os );] // nem duplik\u00e1lunk k\u00f3dot, \u0151sbe deleg\u00e1l\u00e1s os << \", konzultalt: \" << konzultalt ; } }; #endif Neptun #ifndef NEPTUN_H_DEFINED #define NEPTUN_H_DEFINED #include <vector> #include \"polgar.h\" class Neptun [ /*...*/ ] { std :: vector < [ /*...*/ ] > adat ; public : void hozzaad ([ /*...*/ ] b ) { adat .[ /*...*/ ]; } void listaz ( ostream & os ) [ const ] { for ([ /*...*/ ] i = 0 ; i < [ /*...*/ ]; ++ i ) { [ /*...*/ ] kiir ( os ); os << std :: endl ; } } [ /*...*/ ] ~ Neptun (); // k\u00fcl\u00f6n val\u00f3s\u00edtjuk meg }; #endif Megold\u00e1s #ifndef NEPTUN_H_DEFINED #define NEPTUN_H_DEFINED #include <vector> #include \"polgar.h\" class Neptun [ /* \u00fcres */ ] { std :: vector < [ Polgar * ] > adat ; public : void hozzaad ([ Polgar * ] b ) { adat .[ push_back ( b )]; } void listaz ( ostream & os ) [ const ] { for ([ size_t ] i = 0 ; i < [ adat . size ()]; ++ i ) { [ adat [ i ] \u2011 > ] kiir ( os ); os << std :: endl ; } } [ /* \u00fcres */ ] ~ Neptun (); // k\u00fcl\u00f6n val\u00f3s\u00edtjuk meg }; #endif Adapter PyTomb std::vector adapter Az adapter tervez\u00e9si minta l\u00e9nyege a k\u00f6vetkez\u0151: Van egy oszt\u00e1ly, ami elv\u00e1r egy interf\u00e9szt egy m\u00e1sik oszt\u00e1lyt\u00f3l ( Adaptee ), viszont az Adaptee oszt\u00e1ly nem felel meg ennek az interf\u00e9sznek. Ez\u00e9rt k\u00e9sz\u00edt\u00fcnk egy \u00faj oszt\u00e1lyt ( Adapter ), aki megval\u00f3s\u00edtja az elv\u00e1rt interf\u00e9szt az Adaptee oszt\u00e1ly felhaszn\u00e1l\u00e1s\u00e1val. A jelenlegi feladatban egy PyTomb nev\u0171 adaptert kell elk\u00e9sz\u00edteni, ami az std::vector<T> oszt\u00e1ly operator[] tagf\u00fcggv\u00e9ny\u00e9t v\u00e1ltoztatja meg olyan m\u00f3don, hogy negat\u00edv index eset\u00e9n a t\u00f6mb\u00f6t h\u00e1tulr\u00f3l indexel. Elv\u00e1r\u00e1s tov\u00e1bb\u00e1 az is, hogy a PyTomb \u00e9s std::vector kompatiblisek legyenek. Gondolatmenet A kompatibilit\u00e1s miatt fontos, hogy az std::vector<T> -b\u0151l le kell sz\u00e1rmazni. A C++ name lookup szab\u00e1lyai miatt ha egy template param\u00e9tert\u0151l f\u00fcgg\u0151 \u0151soszt\u00e1lyb\u00f3l szeretn\u00e9nk tagf\u00fcggv\u00e9nyt h\u00edvni, akkor ki kell \u00edrni a teljes \u0151soszt\u00e1lyt el\u00e9, pl std::vector<T>::at(idx); Erre az\u00e9rt van sz\u00fcks\u00e9g, mivel a template olvas\u00e1sakor a ford\u00edt\u00f3 a neveket nem keresi a template param\u00e9terekt\u0151l f\u00fcgg\u0151 \u0151soszt\u00e1lyokban (hiszen m\u00e9g nem tudja, hogy melyik template param\u00e9terekkel van haszn\u00e1lva a sablon, \u00e9s explicit specializ\u00e1ci\u00f3k miatt nem tudja, melyik specializ\u00e1ci\u00f3ban keressen.) template < typename T > struct Foo { void f () {} }; template <> struct Foo < int > { void k () {} } template < typename T > struct Bar : Foo < T > { void b () { f (); } /*hiba, nincs tal\u00e1lat f-re, mivel Foo<T> \u0151soszt\u00e1ly f\u00fcgg T-t\u0151l, \u00e9s nem biztos, hogy minden Foo<T> -ben l\u00e9tezik f(), pl itt Foo<int> -ben nem. */ }; Megold\u00e1s template < typename T > class PyTomb : public std :: vector < T > /*dependent base class! figyelni kell a nevekre*/ { public : using std :: vector < T >:: vector ; // minden vector nev\u0171 fgv. \u00e1tv\u00e9tele az std::vector<T> -b\u0151l, \"ctor \u00f6r\u00f6kl\u00e9s\" T & operator []( long long idx ){ if ( idx >= 0 ){ return std :: vector < T >:: at ( idx ); // at tagfgv. csin\u00e1l bounds checkinget is, ezt nek\u00fcnk nem kell megcsin\u00e1lni } else { return std :: vector < T >:: at ( std :: vector < T >:: size () + idx ); } } const T & operator []( long long idx ) const { //ugyanez const-ra is! if ( idx >= 0 ){ return std :: vector < T >:: at ( idx ); // at tagfgv. csin\u00e1l bounds checkinget is, ezt nek\u00fcnk nem kell megcsin\u00e1lni } else { return std :: vector < T >:: at ( std :: vector < T >:: size () + idx ); } } } Iter\u00e1torok Dinamikus t\u00f6mb iter\u00e1tor Eg\u00e9sz\u00edtse ki a lenti dinamikus generikus t\u00f6mb\u00f6t iter\u00e1torral! Az iter\u00e1tort a generikus oszt\u00e1ly bels\u0151 publikus oszt\u00e1lyak\u00e9nt implement\u00e1lja! A megadott k\u00f3dr\u00e9szletekhez ne ny\u00faljon, csak kieg\u00e9sz\u00edtheti azt! Az iter\u00e1tornak a k\u00f6vetkez\u0151 funkci\u00f3kkal kell rendelkeznie: param\u00e9ter n\u00e9lk\u00fcli konstruktor: nullptr \u00e1ll\u00edt be (az iter\u00e1tor \u00e9rv\u00e9nytelen) egyparam\u00e9teres konstruktor: konstans GenDinTomb referenci\u00e1t vesz \u00e1t, a t\u00f6mb elej\u00e9re \u00e1ll\u00edtja az iter\u00e1tort k\u00e9tparam\u00e9teres ctor: konstans GenDinTomb referenci\u00e1t \u00e9s egy size_t indexet vesz \u00e1t, az iter\u00e1tort a t\u00f6mb indexedik elem\u00e9re \u00e1ll\u00edtja derefer\u00e1l\u00f3 ( ) oper\u00e1tor: referenci\u00e1t ad vissza, ha az iter\u00e1tor \u00e9rv\u00e9nytelen (nullptr, t\u00falc\u00edmz\u00e9s), dobjon const char t\u00edpus\u00fa kiv\u00e9telt! \u00d6sszehasonl\u00edt\u00f3 oper\u00e1torok (== \u00e9s !=), \u00f6sszehasonl\u00edt k\u00e9t iter\u00e1tort, logikai \u00e9rt\u00e9kkel t\u00e9r vissza, elv\u00e1rt m\u00f3don m\u0171k\u00f6dj\u00f6n. Preinkremens oper\u00e1tor: Ha az iter\u00e1tor nem \u00e9rv\u00e9nytelen, akkor a k\u00f6vetkez\u0151 elemre mutat a t\u00f6mbben, k\u00fcl\u00f6nben nem csin\u00e1l semmit. #include <iostream> template < typename T > class GenDinTomb { T * elements ; // pointer a din. foglalt adatra size_t n ; // m\u00e9ret public : GenDinTomb ( size_t n , const T & a = T ()); GenDinTomb ( const GenDinTomb & ); GenDinTomb & operator = ( const GenDinTomb & ); size_t size () const { return n ; } void insert ( const T & e ); //seg\u00e9dfgv. ki\u00edrja a t\u00f6mb m\u00e9ret\u00e9t \u00e9s elemeit void printDbg () const ; //--------------------------csak ezt szerkesztheti------------------------- class iterator { //ezt kell meg\u00edrni }; //------------------------------eddig------------------------------- }; Megold\u00e1s Az iter\u00e1tor a pointerek absztrakci\u00f3ja. Az interf\u00e9sz\u00fck hasonl\u00f3 a pointerekhez, viszont extra funkcionalit\u00e1st val\u00f3s\u00edtanak meg. A feladatban bounds checking -et kell implement\u00e1lni, azaz figyelni kell, hogy val\u00f3ban a t\u00f6mb egy elem\u00e9t \u00e9rj\u00fck el az iter\u00e1toron kereszt\u00fcl. Ehhez biztosan kelleni fog 2 tagv\u00e1ltoz\u00f3: A jelenlegi elemet azonos\u00edt\u00f3 (pointer v. index), valamint a t\u00f6mb v\u00e9g\u00e9t azonos\u00edt\u00f3 (pointer v. index). Ebben a megold\u00e1sban a dinamikus t\u00f6mbre mutat\u00f3 pointer + index a t\u00f6mbbe megold\u00e1st v\u00e1lasztottam, de nem ez az egyetlen j\u00f3 megold\u00e1s. class iterator { GenDinTomb < T >* tomb ; //erre a t\u00f6mbre vonatkozik az index size_t current_idx ; //az elem indexe amire az iter\u00e1tor mutat public : iterator () : tomb ( nullptr ), current_idx ( 0 ) {} iterator ( GenDinTomb & tomb ) : tomb ( & tomb ) {} iterator ( GenDinTomb & tomb , size_t idx ) : tomb ( & tomb ), current_idx ( idx ) {} T & operator * () { if ( tomb == nullptr || current_idx >= tomb . size ()){ // ha invalid a t\u00f6mb vagy invalid az index akkor hib\u00e1t kell dobni throw \"Helytelen indirekcio\" ; } return tomb [ current_idx ]; } bool operator == ( const iterator & rhs ) const { return tomb == rhs . tomb && current_idx == rhs . idx ; } bool operator != ( const iterator & rhs ) const { return ! ( * this == rhs ); } iterator & operator ++ (){ if ( tomb != nullptr && current_idx < tomb . size ()){ // ha valid a t\u00f6mb \u00e9s valid az iter\u00e1tor akkor l\u00e9ptetj\u00fck egyet (valid iter\u00e1tor: t\u00f6mbbe vagy egyel a t\u00f6mb ut\u00e1n mutat) current_idx ++ ; } return * this ; } }; STL eszk\u00f6z\u00f6k Indexgen K\u00e9sz\u00edtsen egy olyan f\u00fcggv\u00e9nyt (indexgen n\u00e9ven), ami k\u00e9t param\u00e9tert kap: Egy kezd\u0151 sz\u00e1m\u00e9rt\u00e9ket (int), valamint egy fels\u0151 hat\u00e1rt (int). A f\u00fcggv\u00e9ny feladata egy olyan t\u00f6mb (std::vector ) visszaad\u00e1sa, ami az \u00f6sszes eg\u00e9sz sz\u00e1mot tartalmazza a kezd\u0151 sz\u00e1mt\u00f3l(als\u00f3 hat\u00e1r) a fels\u0151 hat\u00e1rig (azt m\u00e1r nem). A f\u00fcggv\u00e9ny fejl\u00e9c\u00e9t megadtuk, azt ne v\u00e1ltoztassa! Haszn\u00e1lja fel ehhez az std::generate f\u00fcggv\u00e9nyt! For vagy while ciklust ne haszn\u00e1ljon! A megold\u00e1shoz tov\u00e1bbi seg\u00e9df\u00fcggv\u00e9nyt, oszt\u00e1lyt is felvehet! P\u00e9lda a haszn\u00e1latra: std :: vector < int > t = indexgen ( 0 , 4 ); for ( int k : t ) std :: cout << k << ',' ; //0,1,2,3, B. feladatr\u00e9sz: Alak\u00edtsa \u00e1t \u00fagy a f\u00fcggv\u00e9nyt, hogy tetsz\u0151leges t\u00edpusokra m\u0171k\u00f6dj\u00f6n, a posztinkremens \u00e9s a kivon\u00e1s m\u0171velet \u00e9rtelmezve van a t\u00edpuson! (persze ekkor a f\u00fcggv\u00e9nyfejl\u00e9chez hozz\u00e1ny\u00falhat) Gondolatmenet Az std::generate f\u00fcggv\u00e9ny k\u00e9t iter\u00e1tort, valamint egy h\u00edvhat\u00f3 objektumot vesz \u00e1t (gener\u00e1tor). A k\u00e9t iter\u00e1tor k\u00f6zt megy v\u00e9gig, \u00e9s megh\u00edvja a gener\u00e1tort, \u00e9s az iter\u00e1toron kereszt\u00fcl be\u00e1ll\u00edtja az adott elemet a gener\u00e1tor visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u00e9re. // ez t\u00f6rt\u00e9nik a generate belsej\u00e9ben for ( auto it = begin ; it != end ; ++ it ){ * it = generator (); } Megold\u00e1s A. feladatr\u00e9sz: int t\u00edpusra struct CounterFunctor { CounterFunctor ( int x ) : x ( x ) {} int operator ()() { return x ++ ; } private : int x ; }; std :: vector < int > indexgen ( int also , int felso ){ std :: vector < int > result ( felso - also ); //ebben lesz az eredm\u00e9ny, a ctor-ban a m\u00e9retet adjuk meg, hogy a begin \u00e9s end j\u00f3k legyenek. CounterFunctor gen ( also ); // k\u00e9sz\u00edt\u00fcnk egy sz\u00e1ml\u00e1l\u00f3 gener\u00e1tort ami az als\u00f3 \u00e9rt\u00e9kr\u0151k indul std :: generate ( result . begin (), result . end (), gen ); // \u00e1tadjuk az eredm\u00e9ny range-t \u00e9s a gener\u00e1tor p\u00e9ld\u00e1nyt. NEM gen(), hanem gen !! return result ; } B. feladatr\u00e9sz: int helyett minden t\u00edpusra template < typename T > struct CounterFunctor { CounterFunctor ( const T & x ) : x ( x ) {} T operator ()() { return x ++ ; } private : T x ; }; template < typename T > std :: vector < T > indexgen ( const T & also , const T & felso ){ std :: vector < T > result ( felso - also ); //ebben lesz az eredm\u00e9ny, a ctor-ban a m\u00e9retet adjuk meg, hogy a begin \u00e9s end j\u00f3k legyenek. CounterFunctor < T > gen ( also ); // k\u00e9sz\u00edt\u00fcnk egy sz\u00e1ml\u00e1l\u00f3 gener\u00e1tort ami az als\u00f3 \u00e9rt\u00e9kr\u0151k indul. Nem kell a <T>, de ki\u00edrhatjuk std :: generate ( result . begin (), result . end (), gen ); // \u00e1tadjuk az eredm\u00e9ny range-t \u00e9s a gener\u00e1tor p\u00e9ld\u00e1nyt. NEM gen(), hanem gen !! return result ; } Boolindexing K\u00e9sz\u00edtsen egy olyan f\u00fcggv\u00e9nyt boolindexing n\u00e9ven, ami k\u00e9t param\u00e9tert kap: egy vector<int> t\u00f6mb\u00f6t, valamint egy predik\u00e1tumot. A f\u00fcggv\u00e9ny feladata egy olyan logikai t\u00f6mb ( std::vector<bool> ) visszaad\u00e1sa, amiben az 'idx' index\u0171 helyen akkor \u00e1ll igaz, ha az eredeti t\u00f6mbben az idx helyen l\u00e9v\u0151 \u00e9rt\u00e9kre a predik\u00e1tum igaz, k\u00fcl\u00f6nben hamis. Implement\u00e1lja a megold\u00e1shoz a \"paros\" predik\u00e1tumot, ami akkor ad vissza igazat, ha a param\u00e9ter\u00fcl kapott eg\u00e9sz sz\u00e1m p\u00e1ros. Haszn\u00e1lja fel ehhez az std::transform f\u00fcggv\u00e9nyt! For vagy while ciklust ne haszn\u00e1ljon! A megold\u00e1shoz tov\u00e1bbi seg\u00e9df\u00fcggv\u00e9nyt, oszt\u00e1lyt is felvehet! P\u00e9lda a haszn\u00e1latra: std :: vector < int > t = { 1 , 2 , 3 , 4 }; std :: vector < bool > tb = boolindexing ( t , paros ); for ( bool k : tb ) std :: cout << k << ',' ; //0,1,0,1, B. feladatr\u00e9sz: int helyett minden t\u00edpusra Gondolatmenet Az std::transform f\u00fcggv\u00e9ny \u00e1tvesz h\u00e1rom iter\u00e1tort valamint egy h\u00edvhat\u00f3 objektumot (m\u0171velet). A h\u00e1rom iter\u00e1tor a k\u00f6vetkez\u0151t jelenti: * bemeneti range eleje * bemeneti range v\u00e9ge * kimeneti range eleje A m\u0171velet pedig a bemeneti range elemt\u00edpus\u00e1t (Az A. feladatban int ) veszi \u00e1t, \u00e9s a kimeneti range elemt\u00edpus\u00e1t adja vissza (ebben a feladatban bool ). Azaz a transform egy m\u00e1sik, \"kimeneti\" iter\u00e1torral hat\u00e1rozza meg, hogy hova kezdi el \u00edrni az eredm\u00e9nyeket. Az eredm\u00e9nyeket \u00fagy kapja meg, hogy a m\u0171veletet megh\u00edvja a bemeneti range \u00f6sszes elem\u00e9re egyes\u00e9vel \u00e9s a visszaadott \u00e9rt\u00e9ket ki\u00edrja a kimeneti range-be. Bel\u00fcl valami ilyesmi t\u00f6rt\u00e9nik: for ( auto it = begin , it != end ; ++ it ){ * out = muvelet ( * it ); ++ out ; } Megold\u00e1s A. feladatr\u00e9sz template < typename Op > std :: vector < bool > boolindexing ( const std :: vector < int >& v , Op muvelet ){ std :: vector < bool > result ( v . size ()); std :: transform ( v . begin (), v . end (), result . begin (), muvelet ); // input begin, input end, output being, binary op return result ; } A p\u00e9lda paros m\u0171velet pedig egy egyszer\u0171 f\u00fcggv\u00e9ny lesz: bool paros ( int x ){ return x % 2 == 0 ; } B. feladatr\u00e9sz: Csak az int-et kell T -re cser\u00e9lni: template < typename T , typename Op > std :: vector < bool > boolindexing ( const std :: vector < T >& v , Op muvelet ){ std :: vector < bool > result ( v . size ()); std :: transform ( v . begin (), v . end (), result . begin (), muvelet ); // input begin, input end, output being, op return result ; } Egy\u00e9b CodeRunner feladatok MySet Implement\u00e1ljon egy generikus t\u00e1rol\u00f3t, ami halmazk\u00e9nt fog m\u0171k\u00f6dni. Az oszt\u00e1lyt MySet n\u00e9ven implement\u00e1lja. A halmazban t\u00e1rolt elemek t\u00edpus\u00e1t \u00e9s annak m\u00e9ret\u00e9t (size_t) sablonparam\u00e9terk\u00e9nt lehet be\u00e1ll\u00edtani. Alap\u00e9rtelmezetten a halmaz m\u00e9rete 10. Az elemeket egy fix m\u00e9ret\u0171 t\u00f6mbben a sablonoz\u00e1s seg\u00edts\u00e9g\u00e9vel kell elt\u00e1rolni, ezt a t\u00f6mb\u00f6t elements-nek nevezze el. Felt\u00e9telezheti, hogy a megadott t\u00edpusoknak van alap\u00e9rtelmezett konstruktora, tov\u00e1bb\u00e1 \u00e9rv\u00e9nyes rajtuk az \u00f6sszehasonl\u00edt\u00f3 (==) oper\u00e1tor. Figyeljen a l\u00e1that\u00f3s\u00e1gra. Tov\u00e1bb\u00e1: contains met\u00f3dus: igaz logikai \u00e9rt\u00e9ket ad vissza, ha a param\u00e9ter\u00fcl kapott elem benne van a halmazban m\u00e1r, k\u00fcl\u00f6nben hamis \u00e9rt\u00e9ket. insert met\u00f3dus: belerakja a halmazba, a kapott \u00e9rt\u00e9ket (ha nem volt benne). Ha nem volt benne, viszont a halmaz kapacit\u00e1sa (sablonparam\u00e9ter) m\u00e1r nem el\u00e9g, akkor const char* kiv\u00e9telt dob. Ha a param\u00e9ter\u00fcl kapott \u00e9rt\u00e9k m\u00e1r szerepel a halmazban, nem csin\u00e1l semmit. size met\u00f3dus: visszaadja az eddig t\u00e1rolt elemek sz\u00e1m\u00e1t. capacity met\u00f3dus: visszaadja a halmaz kapacit\u00e1s\u00e1t (mennyi k\u00fcl\u00f6nb\u00f6z\u0151 elemet lehet maximum belerakni) Gondolatmenet A feladat l\u00e9nyege a nem-t\u00edpus sablonparam\u00e9ter haszn\u00e1lata. Mivel a sablonparam\u00e9ter ford\u00edt\u00e1si id\u0151ben konstans, ez\u00e9rt lehet t\u00f6mb m\u00e9ret\u00e9hez haszn\u00e1lni. A feladathoz \u00e9ppen ez\u00e9rt nincs sz\u00fcks\u00e9g dinamikus mem\u00f3riakezel\u00e9sre. Megold\u00e1s template < typename T , size_t C = 10 > // milyen t\u00edpust \u00e9s max mennyit t\u00e1rol class MySet { T elements [ C ]; // C ford\u00edt\u00e1si id\u0151ben konstans teh\u00e1t haszn\u00e1lhat\u00f3 t\u00f6mb m\u00e9retk\u00e9nt size_t meret ; // t\u00e9nyleges m\u00e9ret, amennyit beleraktunk m\u00e1r public : MySet () : meret ( 0 ) {} // meret 0-r\u00f3l induljon bool contains ( const T & t ) const { for ( size_t i = 0 ; i < meret ; ++ i ){ if ( elements [ i ] == t ){ return true ; } } return false ; } void insert ( const T & t ){ if ( ! contains ( t )){ // contains felhaszn\u00e1l\u00e1sa! if ( meret >= C ){ throw \"Tele van\" ; } elements [ meret ] = t ; ++ meret ; } } size_t size () const { return meret ; } size_t capacity () const { return C ; } }; Serializable Complex K\u00e9sz\u00edtsen szerializ\u00e1lhat\u00f3 oszt\u00e1lyt a Complex \u00e9s a Serializable oszt\u00e1ly felhaszn\u00e1l\u00e1s\u00e1val: A SComplex legyen kompatibilis mindk\u00e9t oszt\u00e1llyal! A fenti oszt\u00e1lyok deklar\u00e1ci\u00f3ja a k\u00f6vetkez\u0151: class Complex { protected : float r , i ; // r+ij public : Complex ( float r , float i ); float getR () const ; float getI () const ; }; struct Serializable { virtual void write ( std :: ostream & os ) const = 0 ; virtual void read ( std :: istream & is ) = 0 ; }; Az SComplex oszt\u00e1ly write f\u00fcggv\u00e9nye a stream-re a k\u00f6vetkez\u0151 form\u00e1tumban \u00edrja ki az objektum adattagjait: \"SComplex [r]+[i]j\\n\" (a [x] hely\u00e9re az adott adattag ker\u00fcl, p\u00e9ld\u00e1ul \"SComplex 2+3j\" ). A read f\u00fcggv\u00e9ny pedig ilyen form\u00e1ban olvassa be a kiszerializ\u00e1lt adatokat. Ha a read f\u00fcggv\u00e9ny rossz form\u00e1tumot kap (p\u00e9ld\u00e1ul rossz n\u00e9v vagy nem +/j szerepel), akkor kiv\u00e9telt dob a k\u00f6vetkez\u0151 karakterl\u00e1nccal: \"error\" . Megold\u00e1s A szerializ\u00e9ci\u00f3 l\u00e9nyege, hogy a ki\u00edr\u00e1ssal azonos form\u00e1tumban olvassuk vissza az elemeket (ezt a feladat is elv\u00e1rja). Mint a Seralizable, mind a Complex oszt\u00e1lyb\u00f3l sz\u00e1rmaztatunk, viszont a Complex oszt\u00e1lyt csak felhaszn\u00e1ljuk, nem kell bel\u0151le semmit sem \u00fajraimplement\u00e1lni! class SComplex : public Serializable , public Complex { public : SComplex ( float r , float i ) : Complex ( r , i ) {} // Complex ctor-t csak meg kell h\u00edvni, nem kellenek \u00fajra az adattagok. void write ( std :: ostream & os ) const override { os << \"SComplex \" << r << \"+\" << i << \"j\" << std :: endl ; } void read ( std :: istream & is ) override { std :: string type_name ; char op ; char j ; is >> type_name >> r >> op >> i >> j ; if ( op != '+' || j != \"j\" || type_name != \"SComplex\" ) { throw \"error\" ; } } }; A konzult\u00e1ci\u00f3n k\u00e9sz\u00fclt whiteboard","title":"Home"},{"location":"#gyemant-orokles-feladat","text":"\u00daj neptun rendszer (Neptun) ker\u00fcl fejleszt\u00e9sre, heves vit\u00e1k ut\u00e1n a vezet\u0151s\u00e9g a C++ mellett tette le a voks\u00e1t. Feladatunk most egy demo program k\u00e9sz\u00edt\u00e9se a rendszer modellez\u00e9s\u00e9re, amit k\u00e9s\u0151bb lehet hogy tov\u00e1bb b\u0151v\u00edt\u00fcnk. Szeretn\u00e9nk nyilv\u00e1ntartani minden egyetemi polg\u00e1rt ( Polgar ), minden polg\u00e1rnak van neve \u00e9s \u00e9letkora. Az egyetemen a polg\u00e1rokhoz tartoznak a Hallgat\u00f3 k \u00e9s a Tan\u00e1r ok is. A hallgat\u00f3k sz\u00e1mon tartj\u00e1k az eddig teljes\u00edtett kreditek \u00f6sszeg\u00e9t, m\u00edg a tan\u00e1rok az eddig konzult\u00e1lt hallgat\u00f3k sz\u00e1m\u00e1t. Speci\u00e1lis helyzetben vannak a Doktoranduszok, akik hallgat\u00f3k \u00e9s tan\u00e1rok is egyben. Mindenkinek ki\u00edrhat\u00f3 a neve \u00e9s \u00e9letkora, valamint a hallgat\u00f3kn\u00e1l a teljes\u00edtett kredit, tan\u00e1rokn\u00e1l a konzult\u00e1lt hallgat\u00f3k sz\u00e1ma. Doktorandusz viselkedhet tan\u00e1rk\u00e9nt \u00e9s hallgat\u00f3k\u00e9nt is. Minden egyedn\u00e9l ki\u00edrhat\u00f3k ( kiir() ) ezek az \u00e9rt\u00e9kek a kapott ostream param\u00e9terre. A Neptun rendszerbe \u00faj polg\u00e1rt bevinni a hozzaad() met\u00f3dussal lehet, illetve param\u00e9terben megadott adatfolyamra ki lehet list\u00e1zni az \u00f6sszes egyetemi polg\u00e1r minden adat\u00e1t ( listaz() ). Ha a Neptun rendszer megsemmis\u00fcl, a benne t\u00e1rolt adatok is elvesznek.","title":"Gy\u00e9m\u00e1nt \u00f6r\u00f6kl\u00e9s feladat"},{"location":"#gondoljuk-vegig","text":"Az modell\u00fcnk a k\u00f6vetkez\u0151: Van egy Polgar \u0151soszt\u00e1ly Bel\u0151le sz\u00e1rmazik a Tanar \u00e9s a Hallgato A Doktorandusz egyszerre Tanar \u00e9s Hallgato is Ez gy\u00e9m\u00e1nt \u00f6r\u00f6kl\u00e9s probl\u00e9ma! A Doktorandusz oszt\u00e1lyban a Polgar mem\u00f3riak\u00e9pe k\u00e9tszer, a Tanar \u00e9s Hallgato oszt\u00e1lyon kereszt\u00fcl is megjelenik. A megold\u00e1s: virtu\u00e1lis \u0151s kell a Tanar \u00e9s Hallgato oszt\u00e1lynak!","title":"Gondoljuk v\u00e9gig!"},{"location":"#tanar","text":"#ifndef TANAR_H_DEFINED #define TANAR_H_DEFINED #include \"polgar.h\" class Tanar : [ /*...*/ ] { int konzultalt ; //eddig konzult\u00e1lt hallgat\u00f3k sz\u00e1ma public : Tanar ( string nev , int kor , int konzultalt ) [ /*...*/ ], konzultalt ( konzultalt ) {} void kiir ( ostream & os ) const { [ /*...*/ ] // ki\u00edrjuk a nev\u00e9t \u00e9s a kor\u00e1t os << \", konzultalt: \" << konzultalt ; } }; #endif Megold\u00e1s #ifndef TANAR_H_DEFINED #define TANAR_H_DEFINED #include \"polgar.h\" class Tanar : [ virtual public Polgar ] { //virtual base, mivel gy\u00e9m\u00e1nt probl\u00e9ma van. int konzultalt ; //eddig konzult\u00e1lt hallgat\u00f3k sz\u00e1ma public : Tanar ( string nev , int kor , int konzultalt ) [ : Polgar ( nev , kor )], konzultalt ( konzultalt ) {} void kiir ( ostream & os ) const { [ Polgar :: kiir ( os );] // nem duplik\u00e1lunk k\u00f3dot, \u0151sbe deleg\u00e1l\u00e1s os << \", konzultalt: \" << konzultalt ; } }; #endif","title":"Tan\u00e1r"},{"location":"#neptun","text":"#ifndef NEPTUN_H_DEFINED #define NEPTUN_H_DEFINED #include <vector> #include \"polgar.h\" class Neptun [ /*...*/ ] { std :: vector < [ /*...*/ ] > adat ; public : void hozzaad ([ /*...*/ ] b ) { adat .[ /*...*/ ]; } void listaz ( ostream & os ) [ const ] { for ([ /*...*/ ] i = 0 ; i < [ /*...*/ ]; ++ i ) { [ /*...*/ ] kiir ( os ); os << std :: endl ; } } [ /*...*/ ] ~ Neptun (); // k\u00fcl\u00f6n val\u00f3s\u00edtjuk meg }; #endif Megold\u00e1s #ifndef NEPTUN_H_DEFINED #define NEPTUN_H_DEFINED #include <vector> #include \"polgar.h\" class Neptun [ /* \u00fcres */ ] { std :: vector < [ Polgar * ] > adat ; public : void hozzaad ([ Polgar * ] b ) { adat .[ push_back ( b )]; } void listaz ( ostream & os ) [ const ] { for ([ size_t ] i = 0 ; i < [ adat . size ()]; ++ i ) { [ adat [ i ] \u2011 > ] kiir ( os ); os << std :: endl ; } } [ /* \u00fcres */ ] ~ Neptun (); // k\u00fcl\u00f6n val\u00f3s\u00edtjuk meg }; #endif","title":"Neptun"},{"location":"#adapter","text":"","title":"Adapter"},{"location":"#pytomb-stdvector-adapter","text":"Az adapter tervez\u00e9si minta l\u00e9nyege a k\u00f6vetkez\u0151: Van egy oszt\u00e1ly, ami elv\u00e1r egy interf\u00e9szt egy m\u00e1sik oszt\u00e1lyt\u00f3l ( Adaptee ), viszont az Adaptee oszt\u00e1ly nem felel meg ennek az interf\u00e9sznek. Ez\u00e9rt k\u00e9sz\u00edt\u00fcnk egy \u00faj oszt\u00e1lyt ( Adapter ), aki megval\u00f3s\u00edtja az elv\u00e1rt interf\u00e9szt az Adaptee oszt\u00e1ly felhaszn\u00e1l\u00e1s\u00e1val. A jelenlegi feladatban egy PyTomb nev\u0171 adaptert kell elk\u00e9sz\u00edteni, ami az std::vector<T> oszt\u00e1ly operator[] tagf\u00fcggv\u00e9ny\u00e9t v\u00e1ltoztatja meg olyan m\u00f3don, hogy negat\u00edv index eset\u00e9n a t\u00f6mb\u00f6t h\u00e1tulr\u00f3l indexel. Elv\u00e1r\u00e1s tov\u00e1bb\u00e1 az is, hogy a PyTomb \u00e9s std::vector kompatiblisek legyenek. Gondolatmenet A kompatibilit\u00e1s miatt fontos, hogy az std::vector<T> -b\u0151l le kell sz\u00e1rmazni. A C++ name lookup szab\u00e1lyai miatt ha egy template param\u00e9tert\u0151l f\u00fcgg\u0151 \u0151soszt\u00e1lyb\u00f3l szeretn\u00e9nk tagf\u00fcggv\u00e9nyt h\u00edvni, akkor ki kell \u00edrni a teljes \u0151soszt\u00e1lyt el\u00e9, pl std::vector<T>::at(idx); Erre az\u00e9rt van sz\u00fcks\u00e9g, mivel a template olvas\u00e1sakor a ford\u00edt\u00f3 a neveket nem keresi a template param\u00e9terekt\u0151l f\u00fcgg\u0151 \u0151soszt\u00e1lyokban (hiszen m\u00e9g nem tudja, hogy melyik template param\u00e9terekkel van haszn\u00e1lva a sablon, \u00e9s explicit specializ\u00e1ci\u00f3k miatt nem tudja, melyik specializ\u00e1ci\u00f3ban keressen.) template < typename T > struct Foo { void f () {} }; template <> struct Foo < int > { void k () {} } template < typename T > struct Bar : Foo < T > { void b () { f (); } /*hiba, nincs tal\u00e1lat f-re, mivel Foo<T> \u0151soszt\u00e1ly f\u00fcgg T-t\u0151l, \u00e9s nem biztos, hogy minden Foo<T> -ben l\u00e9tezik f(), pl itt Foo<int> -ben nem. */ }; Megold\u00e1s template < typename T > class PyTomb : public std :: vector < T > /*dependent base class! figyelni kell a nevekre*/ { public : using std :: vector < T >:: vector ; // minden vector nev\u0171 fgv. \u00e1tv\u00e9tele az std::vector<T> -b\u0151l, \"ctor \u00f6r\u00f6kl\u00e9s\" T & operator []( long long idx ){ if ( idx >= 0 ){ return std :: vector < T >:: at ( idx ); // at tagfgv. csin\u00e1l bounds checkinget is, ezt nek\u00fcnk nem kell megcsin\u00e1lni } else { return std :: vector < T >:: at ( std :: vector < T >:: size () + idx ); } } const T & operator []( long long idx ) const { //ugyanez const-ra is! if ( idx >= 0 ){ return std :: vector < T >:: at ( idx ); // at tagfgv. csin\u00e1l bounds checkinget is, ezt nek\u00fcnk nem kell megcsin\u00e1lni } else { return std :: vector < T >:: at ( std :: vector < T >:: size () + idx ); } } }","title":"PyTomb std::vector adapter"},{"location":"#iteratorok","text":"","title":"Iter\u00e1torok"},{"location":"#dinamikus-tomb-iterator","text":"Eg\u00e9sz\u00edtse ki a lenti dinamikus generikus t\u00f6mb\u00f6t iter\u00e1torral! Az iter\u00e1tort a generikus oszt\u00e1ly bels\u0151 publikus oszt\u00e1lyak\u00e9nt implement\u00e1lja! A megadott k\u00f3dr\u00e9szletekhez ne ny\u00faljon, csak kieg\u00e9sz\u00edtheti azt! Az iter\u00e1tornak a k\u00f6vetkez\u0151 funkci\u00f3kkal kell rendelkeznie: param\u00e9ter n\u00e9lk\u00fcli konstruktor: nullptr \u00e1ll\u00edt be (az iter\u00e1tor \u00e9rv\u00e9nytelen) egyparam\u00e9teres konstruktor: konstans GenDinTomb referenci\u00e1t vesz \u00e1t, a t\u00f6mb elej\u00e9re \u00e1ll\u00edtja az iter\u00e1tort k\u00e9tparam\u00e9teres ctor: konstans GenDinTomb referenci\u00e1t \u00e9s egy size_t indexet vesz \u00e1t, az iter\u00e1tort a t\u00f6mb indexedik elem\u00e9re \u00e1ll\u00edtja derefer\u00e1l\u00f3 ( ) oper\u00e1tor: referenci\u00e1t ad vissza, ha az iter\u00e1tor \u00e9rv\u00e9nytelen (nullptr, t\u00falc\u00edmz\u00e9s), dobjon const char t\u00edpus\u00fa kiv\u00e9telt! \u00d6sszehasonl\u00edt\u00f3 oper\u00e1torok (== \u00e9s !=), \u00f6sszehasonl\u00edt k\u00e9t iter\u00e1tort, logikai \u00e9rt\u00e9kkel t\u00e9r vissza, elv\u00e1rt m\u00f3don m\u0171k\u00f6dj\u00f6n. Preinkremens oper\u00e1tor: Ha az iter\u00e1tor nem \u00e9rv\u00e9nytelen, akkor a k\u00f6vetkez\u0151 elemre mutat a t\u00f6mbben, k\u00fcl\u00f6nben nem csin\u00e1l semmit. #include <iostream> template < typename T > class GenDinTomb { T * elements ; // pointer a din. foglalt adatra size_t n ; // m\u00e9ret public : GenDinTomb ( size_t n , const T & a = T ()); GenDinTomb ( const GenDinTomb & ); GenDinTomb & operator = ( const GenDinTomb & ); size_t size () const { return n ; } void insert ( const T & e ); //seg\u00e9dfgv. ki\u00edrja a t\u00f6mb m\u00e9ret\u00e9t \u00e9s elemeit void printDbg () const ; //--------------------------csak ezt szerkesztheti------------------------- class iterator { //ezt kell meg\u00edrni }; //------------------------------eddig------------------------------- }; Megold\u00e1s Az iter\u00e1tor a pointerek absztrakci\u00f3ja. Az interf\u00e9sz\u00fck hasonl\u00f3 a pointerekhez, viszont extra funkcionalit\u00e1st val\u00f3s\u00edtanak meg. A feladatban bounds checking -et kell implement\u00e1lni, azaz figyelni kell, hogy val\u00f3ban a t\u00f6mb egy elem\u00e9t \u00e9rj\u00fck el az iter\u00e1toron kereszt\u00fcl. Ehhez biztosan kelleni fog 2 tagv\u00e1ltoz\u00f3: A jelenlegi elemet azonos\u00edt\u00f3 (pointer v. index), valamint a t\u00f6mb v\u00e9g\u00e9t azonos\u00edt\u00f3 (pointer v. index). Ebben a megold\u00e1sban a dinamikus t\u00f6mbre mutat\u00f3 pointer + index a t\u00f6mbbe megold\u00e1st v\u00e1lasztottam, de nem ez az egyetlen j\u00f3 megold\u00e1s. class iterator { GenDinTomb < T >* tomb ; //erre a t\u00f6mbre vonatkozik az index size_t current_idx ; //az elem indexe amire az iter\u00e1tor mutat public : iterator () : tomb ( nullptr ), current_idx ( 0 ) {} iterator ( GenDinTomb & tomb ) : tomb ( & tomb ) {} iterator ( GenDinTomb & tomb , size_t idx ) : tomb ( & tomb ), current_idx ( idx ) {} T & operator * () { if ( tomb == nullptr || current_idx >= tomb . size ()){ // ha invalid a t\u00f6mb vagy invalid az index akkor hib\u00e1t kell dobni throw \"Helytelen indirekcio\" ; } return tomb [ current_idx ]; } bool operator == ( const iterator & rhs ) const { return tomb == rhs . tomb && current_idx == rhs . idx ; } bool operator != ( const iterator & rhs ) const { return ! ( * this == rhs ); } iterator & operator ++ (){ if ( tomb != nullptr && current_idx < tomb . size ()){ // ha valid a t\u00f6mb \u00e9s valid az iter\u00e1tor akkor l\u00e9ptetj\u00fck egyet (valid iter\u00e1tor: t\u00f6mbbe vagy egyel a t\u00f6mb ut\u00e1n mutat) current_idx ++ ; } return * this ; } };","title":"Dinamikus t\u00f6mb iter\u00e1tor"},{"location":"#stl-eszkozok","text":"","title":"STL eszk\u00f6z\u00f6k"},{"location":"#indexgen","text":"K\u00e9sz\u00edtsen egy olyan f\u00fcggv\u00e9nyt (indexgen n\u00e9ven), ami k\u00e9t param\u00e9tert kap: Egy kezd\u0151 sz\u00e1m\u00e9rt\u00e9ket (int), valamint egy fels\u0151 hat\u00e1rt (int). A f\u00fcggv\u00e9ny feladata egy olyan t\u00f6mb (std::vector ) visszaad\u00e1sa, ami az \u00f6sszes eg\u00e9sz sz\u00e1mot tartalmazza a kezd\u0151 sz\u00e1mt\u00f3l(als\u00f3 hat\u00e1r) a fels\u0151 hat\u00e1rig (azt m\u00e1r nem). A f\u00fcggv\u00e9ny fejl\u00e9c\u00e9t megadtuk, azt ne v\u00e1ltoztassa! Haszn\u00e1lja fel ehhez az std::generate f\u00fcggv\u00e9nyt! For vagy while ciklust ne haszn\u00e1ljon! A megold\u00e1shoz tov\u00e1bbi seg\u00e9df\u00fcggv\u00e9nyt, oszt\u00e1lyt is felvehet! P\u00e9lda a haszn\u00e1latra: std :: vector < int > t = indexgen ( 0 , 4 ); for ( int k : t ) std :: cout << k << ',' ; //0,1,2,3, B. feladatr\u00e9sz: Alak\u00edtsa \u00e1t \u00fagy a f\u00fcggv\u00e9nyt, hogy tetsz\u0151leges t\u00edpusokra m\u0171k\u00f6dj\u00f6n, a posztinkremens \u00e9s a kivon\u00e1s m\u0171velet \u00e9rtelmezve van a t\u00edpuson! (persze ekkor a f\u00fcggv\u00e9nyfejl\u00e9chez hozz\u00e1ny\u00falhat) Gondolatmenet Az std::generate f\u00fcggv\u00e9ny k\u00e9t iter\u00e1tort, valamint egy h\u00edvhat\u00f3 objektumot vesz \u00e1t (gener\u00e1tor). A k\u00e9t iter\u00e1tor k\u00f6zt megy v\u00e9gig, \u00e9s megh\u00edvja a gener\u00e1tort, \u00e9s az iter\u00e1toron kereszt\u00fcl be\u00e1ll\u00edtja az adott elemet a gener\u00e1tor visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u00e9re. // ez t\u00f6rt\u00e9nik a generate belsej\u00e9ben for ( auto it = begin ; it != end ; ++ it ){ * it = generator (); } Megold\u00e1s A. feladatr\u00e9sz: int t\u00edpusra struct CounterFunctor { CounterFunctor ( int x ) : x ( x ) {} int operator ()() { return x ++ ; } private : int x ; }; std :: vector < int > indexgen ( int also , int felso ){ std :: vector < int > result ( felso - also ); //ebben lesz az eredm\u00e9ny, a ctor-ban a m\u00e9retet adjuk meg, hogy a begin \u00e9s end j\u00f3k legyenek. CounterFunctor gen ( also ); // k\u00e9sz\u00edt\u00fcnk egy sz\u00e1ml\u00e1l\u00f3 gener\u00e1tort ami az als\u00f3 \u00e9rt\u00e9kr\u0151k indul std :: generate ( result . begin (), result . end (), gen ); // \u00e1tadjuk az eredm\u00e9ny range-t \u00e9s a gener\u00e1tor p\u00e9ld\u00e1nyt. NEM gen(), hanem gen !! return result ; } B. feladatr\u00e9sz: int helyett minden t\u00edpusra template < typename T > struct CounterFunctor { CounterFunctor ( const T & x ) : x ( x ) {} T operator ()() { return x ++ ; } private : T x ; }; template < typename T > std :: vector < T > indexgen ( const T & also , const T & felso ){ std :: vector < T > result ( felso - also ); //ebben lesz az eredm\u00e9ny, a ctor-ban a m\u00e9retet adjuk meg, hogy a begin \u00e9s end j\u00f3k legyenek. CounterFunctor < T > gen ( also ); // k\u00e9sz\u00edt\u00fcnk egy sz\u00e1ml\u00e1l\u00f3 gener\u00e1tort ami az als\u00f3 \u00e9rt\u00e9kr\u0151k indul. Nem kell a <T>, de ki\u00edrhatjuk std :: generate ( result . begin (), result . end (), gen ); // \u00e1tadjuk az eredm\u00e9ny range-t \u00e9s a gener\u00e1tor p\u00e9ld\u00e1nyt. NEM gen(), hanem gen !! return result ; }","title":"Indexgen"},{"location":"#boolindexing","text":"K\u00e9sz\u00edtsen egy olyan f\u00fcggv\u00e9nyt boolindexing n\u00e9ven, ami k\u00e9t param\u00e9tert kap: egy vector<int> t\u00f6mb\u00f6t, valamint egy predik\u00e1tumot. A f\u00fcggv\u00e9ny feladata egy olyan logikai t\u00f6mb ( std::vector<bool> ) visszaad\u00e1sa, amiben az 'idx' index\u0171 helyen akkor \u00e1ll igaz, ha az eredeti t\u00f6mbben az idx helyen l\u00e9v\u0151 \u00e9rt\u00e9kre a predik\u00e1tum igaz, k\u00fcl\u00f6nben hamis. Implement\u00e1lja a megold\u00e1shoz a \"paros\" predik\u00e1tumot, ami akkor ad vissza igazat, ha a param\u00e9ter\u00fcl kapott eg\u00e9sz sz\u00e1m p\u00e1ros. Haszn\u00e1lja fel ehhez az std::transform f\u00fcggv\u00e9nyt! For vagy while ciklust ne haszn\u00e1ljon! A megold\u00e1shoz tov\u00e1bbi seg\u00e9df\u00fcggv\u00e9nyt, oszt\u00e1lyt is felvehet! P\u00e9lda a haszn\u00e1latra: std :: vector < int > t = { 1 , 2 , 3 , 4 }; std :: vector < bool > tb = boolindexing ( t , paros ); for ( bool k : tb ) std :: cout << k << ',' ; //0,1,0,1, B. feladatr\u00e9sz: int helyett minden t\u00edpusra Gondolatmenet Az std::transform f\u00fcggv\u00e9ny \u00e1tvesz h\u00e1rom iter\u00e1tort valamint egy h\u00edvhat\u00f3 objektumot (m\u0171velet). A h\u00e1rom iter\u00e1tor a k\u00f6vetkez\u0151t jelenti: * bemeneti range eleje * bemeneti range v\u00e9ge * kimeneti range eleje A m\u0171velet pedig a bemeneti range elemt\u00edpus\u00e1t (Az A. feladatban int ) veszi \u00e1t, \u00e9s a kimeneti range elemt\u00edpus\u00e1t adja vissza (ebben a feladatban bool ). Azaz a transform egy m\u00e1sik, \"kimeneti\" iter\u00e1torral hat\u00e1rozza meg, hogy hova kezdi el \u00edrni az eredm\u00e9nyeket. Az eredm\u00e9nyeket \u00fagy kapja meg, hogy a m\u0171veletet megh\u00edvja a bemeneti range \u00f6sszes elem\u00e9re egyes\u00e9vel \u00e9s a visszaadott \u00e9rt\u00e9ket ki\u00edrja a kimeneti range-be. Bel\u00fcl valami ilyesmi t\u00f6rt\u00e9nik: for ( auto it = begin , it != end ; ++ it ){ * out = muvelet ( * it ); ++ out ; } Megold\u00e1s A. feladatr\u00e9sz template < typename Op > std :: vector < bool > boolindexing ( const std :: vector < int >& v , Op muvelet ){ std :: vector < bool > result ( v . size ()); std :: transform ( v . begin (), v . end (), result . begin (), muvelet ); // input begin, input end, output being, binary op return result ; } A p\u00e9lda paros m\u0171velet pedig egy egyszer\u0171 f\u00fcggv\u00e9ny lesz: bool paros ( int x ){ return x % 2 == 0 ; } B. feladatr\u00e9sz: Csak az int-et kell T -re cser\u00e9lni: template < typename T , typename Op > std :: vector < bool > boolindexing ( const std :: vector < T >& v , Op muvelet ){ std :: vector < bool > result ( v . size ()); std :: transform ( v . begin (), v . end (), result . begin (), muvelet ); // input begin, input end, output being, op return result ; }","title":"Boolindexing"},{"location":"#egyeb-coderunner-feladatok","text":"","title":"Egy\u00e9b CodeRunner feladatok"},{"location":"#myset","text":"Implement\u00e1ljon egy generikus t\u00e1rol\u00f3t, ami halmazk\u00e9nt fog m\u0171k\u00f6dni. Az oszt\u00e1lyt MySet n\u00e9ven implement\u00e1lja. A halmazban t\u00e1rolt elemek t\u00edpus\u00e1t \u00e9s annak m\u00e9ret\u00e9t (size_t) sablonparam\u00e9terk\u00e9nt lehet be\u00e1ll\u00edtani. Alap\u00e9rtelmezetten a halmaz m\u00e9rete 10. Az elemeket egy fix m\u00e9ret\u0171 t\u00f6mbben a sablonoz\u00e1s seg\u00edts\u00e9g\u00e9vel kell elt\u00e1rolni, ezt a t\u00f6mb\u00f6t elements-nek nevezze el. Felt\u00e9telezheti, hogy a megadott t\u00edpusoknak van alap\u00e9rtelmezett konstruktora, tov\u00e1bb\u00e1 \u00e9rv\u00e9nyes rajtuk az \u00f6sszehasonl\u00edt\u00f3 (==) oper\u00e1tor. Figyeljen a l\u00e1that\u00f3s\u00e1gra. Tov\u00e1bb\u00e1: contains met\u00f3dus: igaz logikai \u00e9rt\u00e9ket ad vissza, ha a param\u00e9ter\u00fcl kapott elem benne van a halmazban m\u00e1r, k\u00fcl\u00f6nben hamis \u00e9rt\u00e9ket. insert met\u00f3dus: belerakja a halmazba, a kapott \u00e9rt\u00e9ket (ha nem volt benne). Ha nem volt benne, viszont a halmaz kapacit\u00e1sa (sablonparam\u00e9ter) m\u00e1r nem el\u00e9g, akkor const char* kiv\u00e9telt dob. Ha a param\u00e9ter\u00fcl kapott \u00e9rt\u00e9k m\u00e1r szerepel a halmazban, nem csin\u00e1l semmit. size met\u00f3dus: visszaadja az eddig t\u00e1rolt elemek sz\u00e1m\u00e1t. capacity met\u00f3dus: visszaadja a halmaz kapacit\u00e1s\u00e1t (mennyi k\u00fcl\u00f6nb\u00f6z\u0151 elemet lehet maximum belerakni) Gondolatmenet A feladat l\u00e9nyege a nem-t\u00edpus sablonparam\u00e9ter haszn\u00e1lata. Mivel a sablonparam\u00e9ter ford\u00edt\u00e1si id\u0151ben konstans, ez\u00e9rt lehet t\u00f6mb m\u00e9ret\u00e9hez haszn\u00e1lni. A feladathoz \u00e9ppen ez\u00e9rt nincs sz\u00fcks\u00e9g dinamikus mem\u00f3riakezel\u00e9sre. Megold\u00e1s template < typename T , size_t C = 10 > // milyen t\u00edpust \u00e9s max mennyit t\u00e1rol class MySet { T elements [ C ]; // C ford\u00edt\u00e1si id\u0151ben konstans teh\u00e1t haszn\u00e1lhat\u00f3 t\u00f6mb m\u00e9retk\u00e9nt size_t meret ; // t\u00e9nyleges m\u00e9ret, amennyit beleraktunk m\u00e1r public : MySet () : meret ( 0 ) {} // meret 0-r\u00f3l induljon bool contains ( const T & t ) const { for ( size_t i = 0 ; i < meret ; ++ i ){ if ( elements [ i ] == t ){ return true ; } } return false ; } void insert ( const T & t ){ if ( ! contains ( t )){ // contains felhaszn\u00e1l\u00e1sa! if ( meret >= C ){ throw \"Tele van\" ; } elements [ meret ] = t ; ++ meret ; } } size_t size () const { return meret ; } size_t capacity () const { return C ; } };","title":"MySet"},{"location":"#serializable-complex","text":"K\u00e9sz\u00edtsen szerializ\u00e1lhat\u00f3 oszt\u00e1lyt a Complex \u00e9s a Serializable oszt\u00e1ly felhaszn\u00e1l\u00e1s\u00e1val: A SComplex legyen kompatibilis mindk\u00e9t oszt\u00e1llyal! A fenti oszt\u00e1lyok deklar\u00e1ci\u00f3ja a k\u00f6vetkez\u0151: class Complex { protected : float r , i ; // r+ij public : Complex ( float r , float i ); float getR () const ; float getI () const ; }; struct Serializable { virtual void write ( std :: ostream & os ) const = 0 ; virtual void read ( std :: istream & is ) = 0 ; }; Az SComplex oszt\u00e1ly write f\u00fcggv\u00e9nye a stream-re a k\u00f6vetkez\u0151 form\u00e1tumban \u00edrja ki az objektum adattagjait: \"SComplex [r]+[i]j\\n\" (a [x] hely\u00e9re az adott adattag ker\u00fcl, p\u00e9ld\u00e1ul \"SComplex 2+3j\" ). A read f\u00fcggv\u00e9ny pedig ilyen form\u00e1ban olvassa be a kiszerializ\u00e1lt adatokat. Ha a read f\u00fcggv\u00e9ny rossz form\u00e1tumot kap (p\u00e9ld\u00e1ul rossz n\u00e9v vagy nem +/j szerepel), akkor kiv\u00e9telt dob a k\u00f6vetkez\u0151 karakterl\u00e1nccal: \"error\" . Megold\u00e1s A szerializ\u00e9ci\u00f3 l\u00e9nyege, hogy a ki\u00edr\u00e1ssal azonos form\u00e1tumban olvassuk vissza az elemeket (ezt a feladat is elv\u00e1rja). Mint a Seralizable, mind a Complex oszt\u00e1lyb\u00f3l sz\u00e1rmaztatunk, viszont a Complex oszt\u00e1lyt csak felhaszn\u00e1ljuk, nem kell bel\u0151le semmit sem \u00fajraimplement\u00e1lni! class SComplex : public Serializable , public Complex { public : SComplex ( float r , float i ) : Complex ( r , i ) {} // Complex ctor-t csak meg kell h\u00edvni, nem kellenek \u00fajra az adattagok. void write ( std :: ostream & os ) const override { os << \"SComplex \" << r << \"+\" << i << \"j\" << std :: endl ; } void read ( std :: istream & is ) override { std :: string type_name ; char op ; char j ; is >> type_name >> r >> op >> i >> j ; if ( op != '+' || j != \"j\" || type_name != \"SComplex\" ) { throw \"error\" ; } } };","title":"Serializable Complex"},{"location":"#a-konzultacion-keszult-whiteboard","text":"","title":"A konzult\u00e1ci\u00f3n k\u00e9sz\u00fclt whiteboard"}]}